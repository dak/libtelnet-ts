<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>libtelnet-ts</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">libtelnet-ts</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>libtelnet-ts</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><a href="https://github.com/seanmiddleditch/libtelnet/actions"><img src="https://github.com/seanmiddleditch/libtelnet/workflows/CI/badge.svg" alt="Actions Status"></a></p>
				<a href="#libtelnet---telnet-protocol-handling-library" id="libtelnet---telnet-protocol-handling-library" style="color: inherit; text-decoration: none;">
					<h1>libtelnet - TELNET protocol handling library</h1>
				</a>
				<p><a href="http://github.com/seanmiddleditch/libtelnet">http://github.com/seanmiddleditch/libtelnet</a></p>
				<p>Sean Middleditch and contributors</p>
				<p>The author or authors of this code dedicate any and all copyright
					interest in this code to the public domain. We make this dedication
					for the benefit of the public at large and to the detriment of our
					heirs and successors. We intend this dedication to be an overt act of
					relinquishment in perpetuity of all present and future rights to this
				code under copyright law.</p>
				<a href="#i-introduction" id="i-introduction" style="color: inherit; text-decoration: none;">
					<h2>I. Introduction</h2>
				</a>
				<p>libtelnet provides safe and correct handling of the core TELNET
					protocol. In addition to the base TELNET protocol, libtelnet also
					implements the Q method of TELNET option negotiation. libtelnet can
				be used for writing servers, clients, or proxies.</p>
				<p>For more information on the TELNET standards supported by libtelnet,
				visit the following websites:</p>
				<ul>
					<li><a href="http://www.faqs.org/rfcs/rfc854.html">http://www.faqs.org/rfcs/rfc854.html</a></li>
					<li><a href="http://www.faqs.org/rfcs/rfc855.html">http://www.faqs.org/rfcs/rfc855.html</a></li>
					<li><a href="http://www.faqs.org/rfcs/rfc1091.html">http://www.faqs.org/rfcs/rfc1091.html</a></li>
					<li><a href="http://www.faqs.org/rfcs/rfc1143.html">http://www.faqs.org/rfcs/rfc1143.html</a></li>
					<li><a href="http://www.faqs.org/rfcs/rfc1408.html">http://www.faqs.org/rfcs/rfc1408.html</a></li>
					<li><a href="http://www.faqs.org/rfcs/rfc1572.html">http://www.faqs.org/rfcs/rfc1572.html</a></li>
				</ul>
				<a href="#ii-ts-api" id="ii-ts-api" style="color: inherit; text-decoration: none;">
					<h2>II. TS API</h2>
				</a>
				<p>The TS api is a simple wrapper for the libtelnet package.</p>
				<a href="#iii-c-api" id="iii-c-api" style="color: inherit; text-decoration: none;">
					<h2>III. C API</h2>
				</a>
				<p>The libtelnet API contains several distinct parts. The first part is
					the basic initialization and deinitialization routines. The second
					part is a single function for pushing received data into the telnet
					processor. The third part is the libtelnet output functions, which
					generate TELNET commands and ensure data is properly formatted before
					sending over the wire. The final part is the event handler
				interface.</p>
				<p>This document covers only the most basic functions. See the
					libtelnet manual pages or HTML documentation for a complete
				reference.</p>
				<a href="#iiia-initialization" id="iiia-initialization" style="color: inherit; text-decoration: none;">
					<h4>IIIa. Initialization</h4>
				</a>
				<p>Using libtelnet requires the initialization of a telnet_t structure
				which stores all current state for a single TELNET connection.</p>
				<p>Initializing a telnet_t structure requires several pieces of data.
					One of these is the telopt support table, which specifies which
					TELNET options your application supports both locally and remotely.
					This table is comprised of telnet_telopt_t structures, one for each
					supported option. Each entry specifies the option supported,
				whether the option is supported locally or remotely.</p>
				<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">telnet_telopt_t</span> {</span>
    short telopt;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> us;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> him;
};</code></pre>
				<p>The us field denotes whether your application supports the telopt
					locally. It should be set to TELNET_WILL if you support it and to
					TELNET_WONT if you don&#39;t. The him field denotes whether the telopt
					is supported on the remote end, and should be TELNET_DO if yes and
				TELNET_DONT if not.</p>
				<p>When definition the telopt table you must include an end marker
					entry, which is simply an entry with telopt set to -1. For
				example:</p>
				<pre><code class="language-c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">telnet_telopt_t</span> my_telopts[] = {
    { TELNET_TELOPT_ECHO,      TELNET_WILL, TELNET_DONT },
    { TELNET_TELOPT_TTYPE,     TELNET_WILL, TELNET_DONT },
    { TELNET_TELOPT_COMPRESS2, TELNET_WONT, TELNET_DO   },
    { TELNET_TELOPT_ZMP,       TELNET_WONT, TELNET_DO   },
    { TELNET_TELOPT_MSSP,      TELNET_WONT, TELNET_DO   },
    { TELNET_TELOPT_BINARY,    TELNET_WILL, TELNET_DO   },
    { TELNET_TELOPT_NAWS,      TELNET_WILL, TELNET_DONT },
    { <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }
};</code></pre>
				<p>If you need to dynamically alter supported options on a
					per-connection basis then you may use a different table
					(dynamically allocated if necessary) per call to telnet_init() or
					you share a single constant table like the above example between
					all connections if you support a fixed set of options. Most
				applications will support only a fixed set of options.</p>
				<ul>
					<li><p><code>telnet_t *telnet_init(const telnet_telopts_t *telopts, telnet_event_handler_t handler, unsigned char flags, void *user_data);</code></p>
						<p>The telnet_init() function is responsible for allocating memory
							and initializing the data in a telnet_t structure. It must be
							called immediately after establishing a connection and before any
						other libtelnet API calls are made.</p>
						<p>The telopts field is the telopt support table as described above.</p>
						<p>The handler parameter must be a function matching the
							telnet_event_handler_t definition. More information about events
						can be found in section IId.</p>
						<p>The user_data parameter is passed to the event handler whenver it
							is invoked. This will usually be a structure container
							information about the connection, including a socket descriptor
						for implementing TELNET_EV_SEND event handling.</p>
						<p>The flags parameter can be any of the following flag constants
						bit-or&#39;d together, or 0 to leave all options disabled.</p>
						<p>TELNET_FLAG_PROXY
							Operate in proxy mode. This disables the RFC1143 support and
						enables automatic detection of COMPRESS2 streams.</p>
						<p>TELNET_FLAG_NVT_EOL
							Receive data with translation of the TELNET NVT CR NUL and CR LF
							sequences specified in RFC854 to C carriage return (\r) and C
						newline (\n), respectively.</p>
						<p>If telnet_init() fails to allocate the required memory, the
						returned pointer will be zero.</p>
					</li>
					<li><p><code>void telnet_free(telnet_t *telnet);</code></p>
						<p>Releases any internal memory allocated by libtelnet for the given
							telnet pointer. This must be called whenever a connection is
							closed, or you will incur memory leaks. The pointer passed in may
						no longer be used afterwards.</p>
					</li>
				</ul>
				<a href="#iiib-receiving-data" id="iiib-receiving-data" style="color: inherit; text-decoration: none;">
					<h4>IIIb. Receiving Data</h4>
				</a>
				<ul>
					<li><p><code>void telnet_recv(telnet_t *telnet, const char *buffer, unsigned int size, void *user_data);</code></p>
						<p>When your application receives data over the socket from the
						remote end, it must pass the received bytes into this function.</p>
						<p>As the TELNET stream is parsed, events will be generated and
							passed to the event handler given to telnet_init(). Of particular
							interest for data receiving is the TELNET_EV_DATA event, which is
							triggered for any regular data such as user input or server
						process output.</p>
					</li>
				</ul>
				<a href="#iiic-sending-data" id="iiic-sending-data" style="color: inherit; text-decoration: none;">
					<h4>IIIc. Sending Data</h4>
				</a>
				<p>All of the output functions will invoke the TELNET_EV_SEND event.</p>
				<p>Note: it is very important that ALL data sent to the remote end of
					the connection be passed through libtelnet. All user input or
					process output that you wish to send over the wire should be given
					to one of the following functions. Do NOT send or buffer
				unprocessed output data directly!</p>
				<ul>
					<li><p><code>void telnet_iac(telnet_t *telnet, unsigned char cmd);</code></p>
						<p>Sends a single &quot;simple&quot; TELNET command, such as the GO-AHEAD
						commands (255 249).</p>
					</li>
					<li><p><code>void telnet_negotiate(telnet_t *telnet, unsigned char cmd, unsigned char opt);</code></p>
						<p>Sends a TELNET negotiation command. The cmd parameter must be one
							of TELNET_WILL, TELNET_WONT, TELNET_DO, or TELNET_DONT. The opt
						parameter is the option to negotiate.</p>
						<p>Unless in PROXY mode, the RFC1143 support may delay or ellide the
							request entirely, as appropriate. It will ignore duplicate
							invocations, such as asking for WILL NAWS when NAWS is already on
						or is currently awaiting response from the remote end.</p>
					</li>
					<li><p><code>void telnet_send(telnet_t *telnet, const char *buffer, size_t size);</code></p>
						<p>Sends raw data, which would be either the process output from a
						server or the user input from a client.</p>
						<p>For sending regular text it may be more convenient to use
						telnet_printf().</p>
					</li>
					<li><p><code>void telnet_send_text(telnet_t *telnet, const char *buffer, size_t size);</code></p>
						<p>Sends text characters with translation of C newlines (\n) into
							CR LF and C carriage returns (\r) into CR NUL, as required by
						RFC854, unless transmission in BINARY mode has been negotiated.</p>
						<p>For sending regular text it may be more convenient to use
						telnet_printf().</p>
					</li>
					<li><p><code>void telnet_begin_sb(telnet_t *telnet, unsigned char telopt);</code></p>
						<p>Sends the header for a TELNET sub-negotiation command for the
							specified option. All send data following this command will be
							part of the sub-negotiation data until a call is made to
						telnet_finish_subnegotiation().</p>
						<p>You should not use telnet_printf() for sending subnegotiation
							data as it will perform newline translations that usually do not
						need to be done for subnegotiation data, and may cause problems.</p>
					</li>
					<li><p><code>void telnet_finish_sb(telnet_t *telnet);</code></p>
						<p>Sends the end marker for a TELNET sub-negotiation command. This
							must be called after (and only after) a call has been made to
							telnet_begin_subnegotiation() and any negotiation data has been
						sent.</p>
					</li>
					<li><p><code>void telnet_subnegotiation(telnet_t *telnet, unsigned char telopt, const char *buffer, unsigned int size);</code></p>
						<p>Sends a TELNET sub-negotiation command. The telopt parameter is
						the sub-negotiation option.</p>
						<p>Note that this function is just a shorthand for:</p>
						<pre><code> telnet<span class="hljs-constructor">_begin_sb(<span class="hljs-params">telnet</span>, <span class="hljs-params">telopt</span>)</span>;
 telnet<span class="hljs-constructor">_send(<span class="hljs-params">telnet</span>, <span class="hljs-params">buffer</span>, <span class="hljs-params">size</span>)</span>;
 telnet<span class="hljs-constructor">_end_sb(<span class="hljs-params">telnet</span>)</span>;</code></pre><p>For some subnegotiations that involve a lot of complex formatted
							data to be sent, it may be easier to make calls to both
							telnet_begin_sb() and telnet_finish_sb() and using telnet_send()
						or telnet_printf2() to format the data.</p>
						<p>NOTE: telnet_subnegotiation() does have special behavior in
							PROXY mode, as in that mode this function will automatically
						detect the COMPRESS2 marker and enable zlib compression.</p>
					</li>
					<li><p><code>int telnet_printf(telnet_t *telnet, const char *fmt, ...);</code></p>
						<p>This functions very similarly to fprintf, except that output is
							sent through libtelnet for processing. IAC bytes are properly
							escaped, C newlines (\n) are translated into CR LF, and C carriage
							returns (\r) are translated into CR NUL, all as required by
						RFC854. The return code is the length of the formatted text.</p>
						<p>NOTE: due to an internal implementation detail, the maximum
						lenth of the formatted text is 4096 characters.</p>
					</li>
				</ul>
				<a href="#iiid-event-handling" id="iiid-event-handling" style="color: inherit; text-decoration: none;">
					<h4>IIId. Event Handling</h4>
				</a>
				<p>libtelnet relies on an event-handling mechanism for processing the
					parsed TELNET protocol stream as well as for buffering and sending
				output data.</p>
				<p>When you initialize a telnet_t structure with telnet_init() you had
					to pass in an event handler function. This function must meet the
				following prototype:</p>
				<p><code>void (telnet_t *telnet, telnet_event_t *event, void *user_data);</code></p>
				<p>The event structure is detailed below. The user_data value is the
				pointer passed to telnet_init().</p>
				<p>The following is a summary of the most important parts of the
					telnet_event_t data type. Please see the libtelnet manual pages or
				HTML document for a complete reference.</p>
				<pre><code><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">telnet_event_t</span> {</span>
  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">type</span>;</span>

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_t</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">_type</span>;</span>
    const char *buffer;
    size_t size;
  } data;

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">error_t</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">_type</span>;</span>
    const char *file;
    const char *func;
    const char *msg;
    int line;
    telnet_error_t errcode;
  } error;

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iac_t</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">_type</span>;</span>
    unsigned char cmd;
  } iac;

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">negotiate_t</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">_type</span>;</span>
    unsigned char telopt;
  } neg;

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subnegotiate_t</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">telnet_event_type_t</span> <span class="hljs-title">_type</span>;</span>
    const char *buffer;
    size_t size;
    unsigned char telopt;
  } sub;
};</code></pre><p>The enumeration values of telnet_event_type_t are described in
					detail below. Whenever the the event handler is invoked, the
					application must look at the event-&gt;type value and do any necessary
				processing.</p>
				<p>The only event that MUST be implemented is TELNET_EV_SEND. Most
					applications will also always want to implement the event
				TELNET_EV_DATA.</p>
				<p>Here is an example event handler implementation which includes
				handlers for several important events.</p>
				<pre><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_event_handler</span><span class="hljs-params">(<span class="hljs-keyword">telnet_t</span> *telnet, <span class="hljs-keyword">telnet_event_t</span> *ev,
    <span class="hljs-keyword">void</span> *user_data)</span> </span>{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_info</span> *<span class="hljs-title">user</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">user_info</span> *)<span class="hljs-title">user_data</span>;</span>

  <span class="hljs-keyword">switch</span> (ev-&gt;type) {
  <span class="hljs-keyword">case</span> TELNET_EV_DATA:
    process_user_input(user, event-&gt;data.<span class="hljs-built_in">buffer</span>, event-&gt;data.<span class="hljs-built_in">size</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> TELNET_EV_SEND:
    write_to_descriptor(user, event-&gt;data.<span class="hljs-built_in">buffer</span>, event-&gt;data.<span class="hljs-built_in">size</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> TELNET_EV_ERROR:
    fatal_error(<span class="hljs-string">"TELNET error: %s"</span>, event-&gt;error.msg);
    <span class="hljs-keyword">break</span>;
  }
}</code></pre><ul>
					<li><p>TELNET_EV_DATA</p>
						<p>The DATA event is triggered whenever regular data (not part of any
							special TELNET command) is received. For a client, this will be
							process output from the server. For a server, this will be input
						typed by the user.</p>
						<p>The event-&gt;data.buffer value will contain the bytes received and the
							event-&gt;data.size value will contain the number of bytes received.
						Note that event-&gt;data.buffer is not NUL terminated!</p>
						<p>NOTE: there is no guarantee that user input or server output
							will be received in whole lines. If you wish to process data
							a line at a time, you are responsible for buffering the data and
						checking for line terminators yourself!</p>
					</li>
					<li><p>TELNET_EV_SEND</p>
						<p>This event is sent whenever libtelnet has generated data that must
							be sent over the wire to the remove end. Generally that means
							calling send() or adding the data to your application&#39;s output
						buffer.</p>
						<p>The event-&gt;data.buffer value will contain the bytes to send and the
							event-&gt;data.size value will contain the number of bytes to send.
							Note that event-&gt;data.buffer is not NUL terminated, and may include
						NUL characters in its data, so always use event-&gt;data.size!</p>
						<p>NOTE: Your SEND event handler must send or buffer the data in
							its raw form as provided by libtelnet. If you wish to perform
						any kind of preprocessing on data you want to send to the other</p>
					</li>
					<li><p>TELNET_EV_IAC</p>
						<p>The IAC event is triggered whenever a simple IAC command is
							received, such as the IAC EOR (end of record, also called go ahead
						or GA) command.</p>
						<p>The command received is in the event-&gt;iac.cmd value.</p>
						<p>The necessary processing depends on the specific commands; see
						the TELNET RFC for more information.</p>
					</li>
					<li><p>TELNET_EV_WILL / TELNET_EV_DO</p>
						<p>The WILL and DO events are sent when a TELNET negotiation command
						of the same name is received.</p>
						<p>WILL events are sent by the remote end when they wish to be
							allowed to turn an option on on their end, or in confirmation
						after you have sent a DO command to them.</p>
						<p>DO events are sent by the remote end when they wish for you to
							turn on an option on your end, or in confirmation after you have
						sent a WILL command to them.</p>
						<p>In either case, the TELNET option under negotiation will be in
						event-&gt;neg.telopt field.</p>
						<p>libtelnet manages most of the pecularities of negotiation for you.
						For information on libtelnet&#39;s negotiation method, see:</p>
						<p><a href="http://www.faqs.org/rfcs/rfc1143.html">http://www.faqs.org/rfcs/rfc1143.html</a></p>
						<p>Note that in PROXY mode libtelnet will do no processing of its
						own for you.</p>
					</li>
					<li><p>TELNET_EV_WONT / TELNET_EV_DONT</p>
						<p>The WONT and DONT events are sent when the remote end of the
							connection wishes to disable an option, when they are refusing to
							a support an option that you have asked for, or in confirmation of
						an option you have asked to be disabled.</p>
						<p>Most commonly WONT and DONT events are sent as rejections of
							features you requested by sending DO or WILL events. Receiving
							these events means the TELNET option is not or will not be
						supported by the remote end, so give up.</p>
						<p>Sometimes WONT or DONT will be sent for TELNET options that are
							already enabled, but the remote end wishes to stop using. You
							cannot decline. These events are demands that must be complied
							with. libtelnet will always send the appropriate response back
							without consulting your application. These events are sent to
						allow your application to disable its own use of the features.</p>
						<p>In either case, the TELNET option under negotiation will be in
						event-&gt;neg.telopt field.</p>
						<p>Note that in PROXY mode libtelnet will do no processing of its
						own for you.</p>
					</li>
					<li><p>TELNET_EV_SUBNEGOTIATION</p>
						<p>Triggered whenever a TELNET sub-negotiation has been received.
							Sub-negotiations include the NAWS option for communicating
							terminal size to a server, the NEW-ENVIRON and TTYPE options for
							negotiating terminal features, and MUD-centric protocols such as
						ZMP, MSSP, and MCCP2.</p>
						<p>The event-&gt;sub-&gt;telopt value is the option under sub-negotiation.
							The remaining data (if any) is passed in event-&gt;sub.buffer and
							event-&gt;sub.size. Note that most subnegotiation commands can include
							embedded NUL bytes in the subnegotiation data, and the data
							event-&gt;sub.buffer is not NUL terminated, so always use the
						event-&gt;sub.size value!</p>
						<p>The meaning and necessary processing for subnegotiations are
							defined in various TELNET RFCs and other informal specifications.
							A subnegotiation should never be sent unless the specific option
							has been enabled through the use of the telnet negotiation
						feature.</p>
						<p>TTYPE/ENVIRON/NEW-ENVIRON/MSSP/ZMP SUPPORT:
							libtelnet parses these subnegotiation commands. A special
							event will be sent for each, after the SUBNEGOTIATION event is
							sent. Except in special circumstances, the SUBNEGOTIATION event
							should be ignored for these options and the special events should
						be handled explicitly.</p>
					</li>
					<li><p>TELNET_EV_COMPRESS</p>
						<p>The COMPRESS event notifies the app that COMPRESS2/MCCP2
							compression has begun or ended. Only servers can send compressed
						data, and hence only clients will receive compressed data.</p>
						<p>The event-&gt;command value will be 1 if compression has started and
						will be 0 if compression has ended.</p>
					</li>
					<li><p>TELNET_EV_ZMP</p>
						<p>The event-&gt;zmp.argc field is the number of ZMP parameters, including
							the command name, that have been received. The event-&gt;zmp.argv
							field is an array of strings, one for each ZMP parameter. The
						command name will be in event-&gt;zmp.argv[0].</p>
					</li>
					<li><p>TELNET_EV_TTYPE</p>
						<p>The event-&gt;ttype.cmd field will be either TELNET_TTYPE_SEND,
						TELNET_TTYPE_IS, TELNET_TTYPE_INFO.</p>
						<p>The actual terminal type will be in event-&gt;ttype.name.</p>
					</li>
					<li><p>TELNET_EV_ENVIRON</p>
						<p>The event-&gt;environ.cmd field will be either TELNET_ENVIRON_IS,
						TELNET_ENVIRON_SEND, or TELNET_ENVIRON_INFO.</p>
						<p>The actual environment variable sent or requested will be sent
							in the event-&gt;environ.values field. This is an array of
						structures with the following format:</p>
						<pre><code>  struct telnet_environ_t {
    unsigned char<span class="hljs-built_in"> type;
</span>    const char *var;
    const char *value;
  };</code></pre><p>The number of entries in the event-&gt;environ.values array is
						stored in event-&gt;environ.count.</p>
						<p>Note that libtelnet does not support the ESC byte for ENVIRON/
							NEW-ENVIRON. Data using escaped bytes will not be parsed
						correctly.</p>
					</li>
					<li><p>TELNET_EV_MSSP</p>
						<p>The event-&gt;mssp.values field is an array of telnet_environ_t
							structures. The cmd field in each entry will have an
							unspecified value, while the var and value fields will always
							be set to the MSSP variable and value being set. For multi-value
							MSSP variables, there will be multiple entries in the values
						array for each value, each with the same variable name set.</p>
						<p>The number of entries in the event-&gt;mssp.values array is
						stored in event-&gt;mssp.count.</p>
					</li>
					<li><p>TELNET_EV_WARNING</p>
						<p>The WARNING event is sent whenever something has gone wrong inside
							of libtelnet (possibly due to malformed data sent by the other
							end) but which recovery is (likely) possible. It may be safe to
							continue using the connection, but some data may have been lost or
						incorrectly interpreted.</p>
						<p>The event-&gt;error.msg field will contain a NUL terminated string
						explaining the error.</p>
					</li>
					<li><p>TELNET_EV_ERROR</p>
						<p>Similar to the WARNING event, the ERROR event is sent whenever
							something has gone wrong. ERROR events are non-recoverable,
							however, and the application should immediately close the
							connection. Whatever has happened is likely going only to result
							in garbage from libtelnet. This is most likely to happen when a
						COMPRESS2 stream fails, but other problems can occur.</p>
						<p>The event-&gt;error.msg field will contain a NUL terminated string
						explaining the error.</p>
					</li>
				</ul>
				<a href="#iv-integrating-libtelnet-with-common-muds" id="iv-integrating-libtelnet-with-common-muds" style="color: inherit; text-decoration: none;">
					<h2>IV. Integrating libtelnet with common muds</h2>
				</a>
				<p>FIXME: fill in some notes about how to splice in libtelnet with
				common Diku/Merc/Circle/etc. MUD codebases.</p>
				<a href="#v-safety-and-correctness-considerations" id="v-safety-and-correctness-considerations" style="color: inherit; text-decoration: none;">
					<h2>V. Safety and correctness considerations</h2>
				</a>
				<p>Your existing application may make heavy use of its own output
					buffering and transmission commands, including hand-made routines for
					sending TELNET commands and sub-negotiation requests. There are at
					times subtle issues that need to be handled when communication over
					the TELNET protocol, not least of which is the need to escape any
				byte value 0xFF with a special TELNET command.</p>
				<p>For these reasons, it is very important that applications making use
					of libtelnet always make use of the libtelnet output functions for
				all data being sent over the TELNET connection.</p>
				<p>In particular, if you are writing a client, all user input must be
					passed through to telnet_send(). This also includes any input
				generated automatically by scripts, triggers, or macros.</p>
				<p>For a server, any and all output -- including ANSI/VT100 escape
					codes, regular text, newlines, and so on -- must be passed through to
				telnet_send().</p>
				<p>Any TELNET commands that are to be sent must be given to one of the
				following: telnet_iac, telnet_negotiate, or telnet_subnegotiation().</p>
				<p>If you are attempting to enable COMPRESS2/MCCP2, you must use the
				telnet_begin_compress2() function.</p>
				<a href="#vi-mccp2-compression" id="vi-mccp2-compression" style="color: inherit; text-decoration: none;">
					<h2>VI. MCCP2 compression</h2>
				</a>
				<p>The MCCP2 (COMPRESS2) TELNET extension allows for the compression of
				all traffic sent from server to client. For more information:</p>
				<p><a href="http://www.mudbytes.net/index.php?a=articles&amp;s=mccp">http://www.mudbytes.net/index.php?a=articles&amp;s=mccp</a></p>
				<p>In order for libtelnet to support MCCP2, zlib must be installed and
					enabled when compiling libtelnet. Use -DHAVE_ZLIB to enable zlib
					when compiling libtelnet.c and pass -lz to the linker to link in the
				zlib shared library.</p>
				<p>libtelnet transparently supports MCCP2. For a server to support
					MCCP2, the application must begin negotiation of the COMPRESS2 option
				using telnet_negotiate(), for example:</p>
				<p><code>telnet_negotiate(&amp;telnet, TELNET_WILL, TELNET_OPTION_COMPRESS2, user_data);</code></p>
				<p>If a favorable DO COMPRESS2 is sent back from the client then the
					server application can begin compression at any time by calling
				telnet_begin_compress2().</p>
				<p>If a connection is in PROXY mode and COMPRESS2 support is enabled
					then libtelnet will automatically detect the start of a COMPRESS2
				stream, in either the sending or receiving direction.</p>
				<a href="#vii-zenith-mud-protocol-zmp-support" id="vii-zenith-mud-protocol-zmp-support" style="color: inherit; text-decoration: none;">
					<h2>VII. Zenith MUD Protocol (ZMP) support</h2>
				</a>
				<p>The Zenith MUD Protocol allows applications to send messages across
					the TELNET connection outside of the normal user input/output data
					stream. libtelnet offers some limited support for receiving and
					sending ZMP commands to make implementing a full ZMP stack easier.
				For more information on ZMP:</p>
				<p><a href="http://zmp.sourcemud.org/">http://zmp.sourcemud.org/</a></p>
				<p>For a server to enable ZMP, it must send the WILL ZMP negotitaion:</p>
				<p><code>telnet_negotiate(&amp;telnet, TELNET_WILL, TELNET_TELOPT_ZMP);</code></p>
				<p>For a client to support ZMP it must include ZMP in the telopt table
				passed to telnet_init(), with the him field set to TELNET_DO:</p>
				<p><code>{ TELNET_TELOPT_ZMP, TELNET_WONT, TELNET_DO },</code></p>
				<p>Note that while ZMP is a bi-directional protocol, it is only ever
					enabled on the server end of the connection. This automatically
					enables the client to send ZMP commands. The client must never
				attempt to negotiate ZMP directly using telnet_negotiate().</p>
				<p>Once ZMP is enabled, any ZMP commands received will automatically be
					sent to the event handler function with the TELNET_EV_SUBNEGOTIATION
					event code. The command will automatically be parsed and the ZMP
					parameters will be placed in the event-&gt;argv array and the number of
				parameters will be placed in the event-&gt;argc field.</p>
				<p>NOTE: if an error occured while parsing the ZMP command because it
					was malformed, the event-&gt;argc field will be equal to 0 and the
					event-&gt;argv field will be NULL. You should always check for this
				before attempting to access the parameter array.</p>
				<p>To send ZMP commands to the remote end, use either telnet_send_zmp()
				or telnet_send_zmpv().</p>
				<ul>
					<li><p><code>int telnet_send_zmp(telnet_t *telnet, size_t argv, const char **argv);</code></p>
						<p>Sends a ZMP command to the remote end. The argc parameter is the
							number of ZMP parameters (including the command name!) to be sent.
							The argv parameter is an array of strings containing the
							parameters. The element in argv[0] is the command name itself.
							The argv array must have at least as many elements as the value
						argc.</p>
					</li>
				</ul>
				<a href="#viii-mud-server-status-protocol-mssp-support" id="viii-mud-server-status-protocol-mssp-support" style="color: inherit; text-decoration: none;">
					<h2>VIII. MUD Server Status Protocol (MSSP) support</h2>
				</a>
				<p>MSSP allows for crawlers or other clients to query a MUD server&#39;s
					supported feature list. This allows MUD listing states to
					automatically stay up to date with the MUD&#39;s features, and not
					require MUD administrators to manually update listing sites for
				their MUD. For more information on MSSP:</p>
				<p><a href="http://tintin.sourceforge.net/mssp/">http://tintin.sourceforge.net/mssp/</a></p>
				<a href="#ix-telnet-proxy-utility" id="ix-telnet-proxy-utility" style="color: inherit; text-decoration: none;">
					<h2>IX. Telnet proxy utility</h2>
				</a>
				<p>The telnet-proxy utility is a small application that serves both as a
					testbed for libtelnet and as a powerful debugging tool for TELNET
				servers and clients.</p>
				<p>To use telnet-proxy, you must first compile it using:</p>
				<pre><code> <span class="hljs-variable">$ </span>make</code></pre><p>If you do not have zlib installed and wish to disable MCCP2 support
					then you must first edit the Makefile and remove the -DHAVE_ZLIB and
				the -lz from the compile flags.</p>
				<p>To run telnet-proxy, you simply give it the server&#39;s host name or IP
					address, the server&#39;s port number, and the port number that
					telnet-proxy should listen on. For example, to connect to the server
				on mud.example.com port 7800 and to listen on port 5000, run:</p>
				<pre><code> $ ./telnet-proxy mud.example.com <span class="hljs-number">7800</span> <span class="hljs-number">5000</span></code></pre><p>You can then connect to the host telnet-proxy is running on (e.g.
					127.0.0.1) on port 5000 and you will automatically be proxied into
				mud.example.com.</p>
				<p>telnet-proxy will display status information about the data passing
					through both ends of the tunnel. telnet-proxy can only support a
					single tunnel at a time. It will continue running until an error
				occurs or a terminating signal is sent to the proxy process.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-namespace">
						<a href="modules/consts.html">consts</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-enum">
						<a href="enums/environcommand.html" class="tsd-kind-icon">Environ<wbr>Command</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/environvartype.html" class="tsd-kind-icon">Environ<wbr>Var<wbr>Type</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/ttypecommand.html" class="tsd-kind-icon">TType<wbr>Command</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/telnetcommand.html" class="tsd-kind-icon">Telnet<wbr>Command</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/telneterrorcode.html" class="tsd-kind-icon">Telnet<wbr>Error<wbr>Code</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/telneteventtype.html" class="tsd-kind-icon">Telnet<wbr>Event<wbr>Type</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/telnetflag.html" class="tsd-kind-icon">Telnet<wbr>Flag</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/telnetoption.html" class="tsd-kind-icon">Telnet<wbr>Option</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/compatibilitytable.html" class="tsd-kind-icon">Compatibility<wbr>Table</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/compatibilitytablegenerator.html" class="tsd-kind-icon">Compatibility<wbr>Table<wbr>Generator</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/telnet.html" class="tsd-kind-icon">Telnet</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/telnetevent.html" class="tsd-kind-icon">Telnet<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/icompressevent.html" class="tsd-kind-icon">ICompress<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/idataevent.html" class="tsd-kind-icon">IData<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/ienvironevent.html" class="tsd-kind-icon">IEnviron<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/ienvironvar.html" class="tsd-kind-icon">IEnviron<wbr>Var</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/ierrorevent.html" class="tsd-kind-icon">IError<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/iiacevent.html" class="tsd-kind-icon">IIACEvent</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/imsspevent.html" class="tsd-kind-icon">IMSSPEvent</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/inegotiationevent.html" class="tsd-kind-icon">INegotiation<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/isubnegotiationevent.html" class="tsd-kind-icon">ISubnegotiation<wbr>Event</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/ittype.html" class="tsd-kind-icon">ITType</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/izmpevent.html" class="tsd-kind-icon">IZMPEvent</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/telnetapi.html" class="tsd-kind-icon">TelnetAPI</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#dataeventtype" class="tsd-kind-icon">Data<wbr>Event<wbr>Type</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#erroreventtype" class="tsd-kind-icon">Error<wbr>Event<wbr>Type</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#negotiationeventtype" class="tsd-kind-icon">Negotiation<wbr>Event<wbr>Type</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#telnetnegotiationcommand" class="tsd-kind-icon">Telnet<wbr>Negotiation<wbr>Command</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#telnet" class="tsd-kind-icon">telnet</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#getenvironvars" class="tsd-kind-icon">get<wbr>Environ<wbr>Vars</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>